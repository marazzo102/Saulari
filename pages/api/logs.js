import { supabase } from "../../lib/supabaseClient";

export default async function handler(req, res) {
  if (req.method === 'POST') {
    try {
      const { action, entity, entity_id, user, details } = req.body || {};
      if (!action) return res.status(400).json({ error: 'action é obrigatório' });
      const payload = {
        action,
        entity: entity || null,
        entity_id: entity_id ?? null,
        user: user || null,
        details: details || null,
        created_at: new Date().toISOString(),
      };
      const { data, error } = await supabase.from('logs').insert(payload).select().single();
      if (error) return res.status(500).json({ error: error.message });
      return res.status(201).json(data);
    } catch (e) {
      return res.status(500).json({ error: e.message });
    }
  }

  if (req.method === 'GET') {
    try {
  const { limit = 50 } = req.query;
      let query = supabase
        .from('logs')
        .select('*')
        .order('created_at', { ascending: false })
        .limit(Number(limit));
      // Filtro básico por texto em action, entity, user, details
      // Filtros podem ser aplicados posteriormente via RPC; por ora, sem filtro server-side.
      const { data, error } = await query;
      if (error) return res.status(500).json({ error: error.message });
      return res.status(200).json(data || []);
    } catch (e) {
      return res.status(500).json({ error: e.message });
    }
  }

  return res.status(405).json({ error: 'Method not allowed' });
}

/*
-- SQL sugerido para criar a tabela de logs no Supabase:
create table if not exists public.logs (
  id bigint generated by default as identity primary key,
  created_at timestamp with time zone default now(),
  action text not null,
  entity text,
  entity_id text,
  user text,
  details jsonb
);

-- Opcional: habilitar RLS e políticas conforme necessidade
*/